一、使用EF的savechanges()完後，會更新到實體中（請看以下範例）

User u = new User{
	account = data.account;
	passwd = data.passwd;
	name = data.name;
}

db.User.Add(u);
db.User.savechanges();

int id = u.id;

//User是我們資料庫的model，裡面其實還有id的屬性（但是應該是自動增加的，所以不用給）
//而我們savechanges()完後，我們再輸入int id = u.id; 是可以取得到剛才自動產生的id
//所以用完savechanges()後，我們的變數u會是其資料庫的資料喔！

-------------------------------------------------------------------------------------------------------------
二、AJAX之用法：

	(a)正常寫法：
	
		//全部被勾選的id列表（取得checkbox被選取的陣列)
		var data = $("input[name='checkDownload']:checked").map(function () { return this.id.replace("check_", ""); }).get();

		if (data != []) {
			//傳到controller中
			$.ajax({
				url: "網址",
				data: {
					downloadContext: data
				},
				type: "GET", //也可以選POST（要大寫喔）
				traditional: true   //加入這行是只要是傳陣列給Controller的都要加
			});  
		} else {
			alert("請勾選你要的項目");
		}

	(b)精簡寫法：
	
	$.get("網址",
				{
					ladderSerial: ladder
				}).done(function (result) {
					alert(result);
				});


	(c)post的寫法：
		
	$.ajax({
			
		type: "POST",
			
		url: "@Url.Action("CheckTransactionType")",
			
		data: {
				
			ID: id,
				
			Type: type
			
		},
	
		
		success: function (result) {
				
			alert(result);
			
		}
		
	})


	(d)Post的寫法（傳Model + 有Vaild要傳回去的 + 執行完（success都跑完了）才會繼續執行下一行程式：

	//得到[ValidateAntiForgeryToken]要的值
        var token = $('input[name="__RequestVerificationToken"]').val();

        //有了座標資料後，就可以把全部東西都Ajax到Create了（因為要傳的是Model所以用{{}}）
      $.ajax({
       type: "POST",
       url: "@Url.Action("Create")",
       async: false, 先讓ajax跑完（含success，才會繼續都行下面的程式

       data: {
        __RequestVerificationToken: token,    //要傳回Vaild的值

        formData: {              //用{}包起來的就是Model裡的屬性名稱
         name: "hello",
	 englishName : "jack"
        },

        success: function (response) {
         alert('success');
        },
        error: function (response) {
         alert('error');
        }
       }
      });

------------------------------------------------------------------------------------------------------------
三、RedirectToAction之應用：

	(a)基本型（如在同一個Controller，可免除寫）：
		
		return RedirectToAction("Action名", "Controller名");


	(b)傳一般參數型（int, string, datetime, double ……等）：

		return RedirectToAction("Action名", "Controller名", new {參數名 = 參數值(或者變數)});

	(c)傳Model（只要用逗號分開即可）：

		return RedirectToAction("Action名", "Controller名", Model變數);

	(d)傳Model + 一般參數型：

		？？？？？（改成傳2個Model，或合併到1個Model吧）


PS:也可以用 Redirect("網址")  就可以接到囉！

------------------------------------------------------------------------------------------------------------
四、繫結相關應用：

	(a)List：

		在View中的呈現					Model中的呈現
		---------------					------------------

		<input name="studentID[0]" />			List<string> studentID {get;set;}
		<input name="studentID[1]" />
		<input name="studentID[2]" />

	(b)IEnumerable：（目前自訂的Class型別不太能用，要多研究 => 不過int string這些可以）

		在View中的呈現					Model中的呈現
		---------------					-------------------

		<input name="studentID" />			IEnumerable<string> studentID {get;set;}
		<input name="studentID" />
		<input name="studentID" />

------------------------------------------------------------------------------------------------------------
五、前端呼叫Controller並回傳html字串給前端

@{Html.RenderAction("Action名", "Controller名", new {參數 = 變數值  });}

ps:這個Controller回傳出來要是字串型態（可以用基本字串，或者一段html標籤 => 會在呼叫的地方變成它）

例如：  Action名=getName()   ，回傳的是 "<p>Lee</p>"

<p>hello</p>                         => 執行後    =>   	<p>hello</p>
@{Html.RenderAction("getName"}				<p>Lee</p>


-----------------------------------------------------------------------------------------------------------
六、TempData

用法類似於Session的功用，主要用於跨別的Controller傳資料之用法。

用法：

在一個Controller中輸入  TempData["隨便的名稱"] = 隨便的值（任何類型皆可）;

在第二個Controller中得資料 =>  類別 A = TempData["隨便的名稱"] as XXX;   （因為他會跟Session一樣變成物件，所以要轉型）

--------------------------------------------------------------------------------------------------------------
七、Transaction處理（使用TransactionScope的話，在scope.Complete();沒執行完前有發生例外的話，上面的全部會取消交易）


//使用TransactionScope
   using (TransactionScope scope = new TransactionScope())
   {
    try
    {

	sql語法或者其他交易相關

     //完成
     scope.Complete();

    }
    catch
    {
     return string.Empty;
    }

-------------------------------------------------------------------------------------------------------------
八、一些小邏輯解說：

(a)陣列中放i++

	int[] a = {1, 2, 3, 4, 5}
	i = 2;
	a[i++] = a[i] + 10;

	=>出來的結果 1, 2, 14, 4, 5

	結論：在a[i++]中仍然是只抓到i的值 ，故是a[2]，但因為前面有i++了！所以現在i是3

	=> a[2] = a[3] + 10

(b)陣列中放i--

	int[] a = {1, 2, 3, 4, 5}
	i = 2;
	a[i--] = a[i] + 10;

	=>出來的結果 1, 2, 12, 4, 5

	結論：在a[i--]中仍然是只抓到i的值 ，故是a[2]，但因為前面有i--了！所以現在i是1

	=> a[2] = a[1] + 10

(c)Byte的溢位處理

	byte x = 0, y = 64;

	for(var i = 0; i < 5; i++){
		x += y;
		Console.writeLine(x);
	}

	=>出來結果： 64 128 192 0 64
	=>總結：byte最大值是256，故在第i=3時，值到了256後就會變成0了！之後在第i=4時就用0 再加上 64

------------------------------------------------------------------------------------------------------------
九、IPageList用法簡介筆記：

(1)先去NuGet裝

(2)確認View/Web.config是否有

	<add namespace="PagedList" />
	<add namespace="PagedList.Mvc" />

	這2行，有時候出現Assembly....的錯誤就是這裡沒有

(3)在Controller

	using PagedList;   //先使用using


	//Controller裡面
	[HttpGet]
	public ActionResult Index(int page = 1){
			

		int currentPage = page < 1 ? 1 : page;   //當前的頁數（如果page < 1的話就是1；反之就是page）
		IEnumerable<物件(Class)> data= 取得資料集合;
		IOrderedEnumerable<物件(Class)> pageAllList = data.OrderBy(x => x.ID);   //排序
		IPagedList result = pageAllList.ToPagedList(currentPage, pageSize);


		return View(result);

	}

(4)在View中

	@model IPagedList<Model名>

	@Html.PagedListPager(Model, page => Url.Action("Controller名(基本上是Index)", new { page, 參數名 = 變數值 }), PagedListRenderOptions.ClassicPlusFirstAndLast)

	//上面的Model指的是@model 
	//而 new {page, 參數名 = 變數值}  page是必要傳的，而後面的參數依Controller而變。