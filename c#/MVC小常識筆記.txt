一、使用EF的savechanges()完後，會更新到實體中（請看以下範例）

User u = new User{
	account = data.account;
	passwd = data.passwd;
	name = data.name;
}

db.User.Add(u);
db.User.savechanges();

int id = u.id;

//User是我們資料庫的model，裡面其實還有id的屬性（但是應該是自動增加的，所以不用給）
//而我們savechanges()完後，我們再輸入int id = u.id; 是可以取得到剛才自動產生的id
//所以用完savechanges()後，我們的變數u會是其資料庫的資料喔！

-------------------------------------------------------------------------------------------------------------
二、AJAX之用法：

	(a)正常寫法：
	
		//全部被勾選的id列表（取得checkbox被選取的陣列)
		var data = $("input[name='checkDownload']:checked").map(function () { return this.id.replace("check_", ""); }).get();

		if (data != []) {
			//傳到controller中
			$.ajax({
				url: "網址",
				data: {
					downloadContext: data
				},
				type: "GET", //也可以選POST（要大寫喔）
				traditional: true   //加入這行是只要是傳陣列給Controller的都要加
			});  
		} else {
			alert("請勾選你要的項目");
		}

	(b)精簡寫法：
	
	$.get("網址",
				{
					ladderSerial: ladder
				}).done(function (result) {
					alert(result);
				});


	(c)post的寫法：
		
	$.ajax({
			
		type: "POST",
			
		url: "@Url.Action("CheckTransactionType")",
			
		data: {
				
			ID: id,
				
			Type: type
			
		},
	
		
		success: function (result) {
				
			alert(result);
			
		}
		
	})


	(d)Post的寫法（傳Model + 有Vaild要傳回去的 + 執行完（success都跑完了）才會繼續執行下一行程式：

	//得到[ValidateAntiForgeryToken]要的值
        var token = $('input[name="__RequestVerificationToken"]').val();

        //有了座標資料後，就可以把全部東西都Ajax到Create了（因為要傳的是Model所以用{{}}）
      $.ajax({
       type: "POST",
       url: "@Url.Action("Create")",
       async: false, 先讓ajax跑完（含success，才會繼續都行下面的程式

       data: {
        __RequestVerificationToken: token,    //要傳回Vaild的值

        formData: {              //用{}包起來的就是Model裡的屬性名稱
         name: "hello",
	 englishName : "jack"
        },

        success: function (response) {
         alert('success');
        },
        error: function (response) {
         alert('error');
        }
       }
      });


	(e)Ajax事件介紹（除 success error外）：

		complete： 請求完成時執行的函式(不論結果是success或error)。
		beforeSend：發送請求之前會執行的函式。

		//上2個主要作用於 Process Bar的應用（看第10點）

------------------------------------------------------------------------------------------------------------
三、RedirectToAction之應用：

	(a)基本型（如在同一個Controller，可免除寫）：
		
		return RedirectToAction("Action名", "Controller名");


	(b)傳一般參數型（int, string, datetime, double ……等）：

		return RedirectToAction("Action名", "Controller名", new {參數名 = 參數值(或者變數)});

	(c)傳Model（只要用逗號分開即可）：

		return RedirectToAction("Action名", "Controller名", Model變數);

	(d)傳Model + 一般參數型：

		？？？？？（改成傳2個Model，或合併到1個Model吧）


PS:也可以用 Redirect("網址")  就可以接到囉！

------------------------------------------------------------------------------------------------------------
四、繫結相關應用：

	(a)List：

		在View中的呈現					Model中的呈現
		---------------					------------------

		<input name="studentID[0]" />			List<string> studentID {get;set;}
		<input name="studentID[1]" />
		<input name="studentID[2]" />

	(b)IEnumerable：（目前自訂的Class型別不太能用，要多研究 => 不過int string這些可以）

		在View中的呈現					Model中的呈現
		---------------					-------------------

		<input name="studentID" />			IEnumerable<string> studentID {get;set;}
		<input name="studentID" />
		<input name="studentID" />

------------------------------------------------------------------------------------------------------------
五、前端呼叫Controller並回傳html字串給前端 +  取到 js 或 css 的路徑

@{Html.RenderAction("Action名", "Controller名", new {參數 = 變數值  });}

ps:這個Controller回傳出來要是字串型態（可以用基本字串，或者一段html標籤 => 會在呼叫的地方變成它）

例如：  Action名=getName()   ，回傳的是 "<p>Lee</p>" 例如： public string getName(){ return "<p>Lee</p>";}

<p>hello</p>                         => 執行後    =>   	<p>hello</p>
@{Html.RenderAction("getName")}				<p>Lee</p>


用 @Url.Content("~/Script/a.js") => 就可以取到真實的路徑囉！

-----------------------------------------------------------------------------------------------------------
六、TempData

用法類似於Session的功用，主要用於跨別的Controller傳資料之用法。

用法：

在一個Controller中輸入  TempData["隨便的名稱"] = 隨便的值（任何類型皆可）;

在第二個Controller中得資料 =>  類別 A = TempData["隨便的名稱"] as XXX;   （因為他會跟Session一樣變成物件，所以要轉型）

--------------------------------------------------------------------------------------------------------------
七、Transaction處理（使用TransactionScope的話，在scope.Complete();沒執行完前有發生例外的話，上面的全部會取消交易）


//使用TransactionScope
   using (TransactionScope scope = new TransactionScope())
   {
    try
    {

	sql語法或者其他交易相關

     //完成
     scope.Complete();

    }
    catch
    {
     return string.Empty;
    }

***如果出現： 已停用分散式交易管理員 (MSDTC) 的網路存取。請使用元件服務系統管理工具啟用 DTC，以使用 MSDTC 安全性設定中的網路存取。

有以上問題，請改成 using (TransactionScope scope =new TransactionScope(TransactionScopeOption.Suppress))

參考網圵：https://dotblogs.com.tw/wasichris/2017/05/31/150157

-------------------------------------------------------------------------------------------------------------
八、一些小邏輯解說：

(a)陣列中放i++

	int[] a = {1, 2, 3, 4, 5}
	i = 2;
	a[i++] = a[i] + 10;

	=>出來的結果 1, 2, 14, 4, 5

	結論：在a[i++]中仍然是只抓到i的值 ，故是a[2]，但因為前面有i++了！所以現在i是3

	=> a[2] = a[3] + 10

(b)陣列中放i--

	int[] a = {1, 2, 3, 4, 5}
	i = 2;
	a[i--] = a[i] + 10;

	=>出來的結果 1, 2, 12, 4, 5

	結論：在a[i--]中仍然是只抓到i的值 ，故是a[2]，但因為前面有i--了！所以現在i是1

	=> a[2] = a[1] + 10

(c)Byte的溢位處理

	byte x = 0, y = 64;

	for(var i = 0; i < 5; i++){
		x += y;
		Console.writeLine(x);
	}

	=>出來結果： 64 128 192 0 64
	=>總結：byte最大值是256，故在第i=3時，值到了256後就會變成0了！之後在第i=4時就用0 再加上 64

------------------------------------------------------------------------------------------------------------
九、IPageList用法簡介筆記：

(1)先去NuGet裝

(2)確認View/Web.config是否有

	<add namespace="PagedList" />
	<add namespace="PagedList.Mvc" />

	這2行，有時候出現Assembly....的錯誤就是這裡沒有

(3)在Controller

	using PagedList;   //先使用using


	//Controller裡面
	[HttpGet]
	public ActionResult Index(int page = 1){
			

		int currentPage = page < 1 ? 1 : page;   //當前的頁數（如果page < 1的話就是1；反之就是page）
		IEnumerable<物件(Class)> data= 取得資料集合;
		IOrderedEnumerable<物件(Class)> pageAllList = data.OrderBy(x => x.ID);   //排序
		IPagedList result = pageAllList.ToPagedList(currentPage, pageSize);


		return View(result);

	}

(4)在View中

	@model IPagedList<Model名>

	@Html.PagedListPager(Model, page => Url.Action("Controller名(基本上是Index)", new { page, 參數名 = 變數值 }), PagedListRenderOptions.ClassicPlusFirstAndLast)

	//上面的Model指的是@model 
	//而 new {page, 參數名 = 變數值}  page是必要傳的，而後面的參數依Controller而變。

------------------------------------------------------------------------------------------------------------
十、Process Bar

(a) Ajax事件介紹：

complete： 請求完成時執行的函式(不論結果是success或error)。
beforeSend：發送請求之前會執行的函式。

(b)程式碼介紹：

<html>
    <head>
        <title></title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <script type="text/javascript" src="jquery.js"></script>
        <script>
        var Submit=function(){
            var URLs="back.php";
            
            $.ajax({
                url: URLs,
                data: $('#sentToBack').serialize(),
                type:"POST",
                dataType:'text',
                success: function(msg){
                    alert(msg);
                },
               
		//主要用beforeSend和complete做Process Bar的開關
		//如果今天不是ajax，也一樣是用Process Bar 的 show 和 hide來操作
		beforeSend:function(){
                    $('#loadingIMG').show();
                },
                complete:function(){
                    $('#loadingIMG').hide();
                },

                error:function(xhr, ajaxOptions, thrownError){ 
                    alert(xhr.status); 
                    alert(thrownError); 
                }
            });
        }

        </script>
    </head>
    <body>
     <form id="sentToBack">
            <input type="text" name="Text"/> 
            <input type="button"  value="送出" onClick="Submit()"/>
        </form>

	<!--Process Bar的部份-->
        <div id=" loadingIMG" style="display:none"><img src="loading.gif" height='14'/>資料處理中，請稍後。</div>

    </body>
</html>

(c)Process Bar的圖片下載網址（可以進行製作圖檔）

http://www.ajaxload.info/



(d)更簡單的應用(但比較沒那麼好)

	(1)在每個Form表單中加上：

		$('form').submit(function () {
        		$('body').loading();   //主要是這段
        		return true; 
    		});

	(2)而在Ajax中加的是(同上面，一樣是這3個事件時觸發)：


		error: function (xhr, textStatus, errorThrown) {
                    $('body').loading('stop');    //主要
                }
                , beforeSend: function (xhr) {
                    $('body').loading();          //主要
                }
                , complete: function () {
                    $('body').loading('stop');    //主要
                }
   	});

------------------------------------------------------------------------------------------------------------
十一、View中的checkbox的繫結

在checkbox中如果要繫結一定要加上 value="true" 才能成功傳到後端（如果value不是true，則都傳不回去）

例： <input type="checkbox" id="c" name="c" value="true" />

------------------------------------------------------------------------------------------------------------
十二、在Controller取得前一個頁面的網址

string preURL = System.Web.HttpContext.Current.Request.Headers["Referer"].ToString();

------------------------------------------------------------------------------------------------------------
十三、將一整個List轉型成另一個List (例如： string[] => int[])：

string[] tid = {"1", "2", "3"};
int[] id = tid.Select(int.Parse).ToArray();

如果要轉成字串的話：
int[] num = [1, 2, 3];
string[] id = num.Select(n => n.ToString()).ToArray();

----------------------------------------------------------------------------------------------------------
十四、基礎型的AutoMapper寫法：

     var dbResult = new List<VIP>();
    var config = new MapperConfiguration(cfg => cfg.CreateMap<VIP, Member>())
    //var config = new MapperConfiguration(cfg => cfg.CreateMap<轉型的資料Class, 要轉成的Class>());
    config.AssertConfigurationIsValid();
    var mapper = config.CreateMapper();
    //左邊是原資料型別，右邊是帶出的資料型別
    return mapper.Map<List<VIP>, List<Member>>(dbResult);
    //return mapper.Map<轉型的資料類型, 轉出的資料類型>(dbResult);

------------------------------------------------------------------------------------------------------------
十五、C#簡單使用 StoredProcedure：

//使用SP
	//ConnectionHelpr.GetADOConnectionString() 這邊是自己改變，反正就是要得到 sql連線字串
    using (SqlConnection conn = new SqlConnection(ConnectionHelpr.GetADOConnectionString()))
    {
     SqlCommand cmd = new SqlCommand("SP的名稱", conn);
     cmd.CommandType = CommandType.StoredProcedure;

     //以下是傳入參數

     //傳入VarChar型別
     cmd.Parameters.Add("@InputText", SqlDbType.VarChar);
     cmd.Parameters["@InputText"].Value = "aaa";

     cmd.Parameters.Add("@InputNo", SqlDbType.Int);
     cmd.Parameters["@InputNo"].Value = 30;

     #region 輸出的部分（前提是你的SP有回傳值）
     // @RESULT 是你在SP中的回傳變數名稱，後面的SqlDbType.Bit是回傳型別
     SqlParameter retValParam = cmd.Parameters.Add("@RESULT", SqlDbType.Bit);
     retValParam.Direction = ParameterDirection.ReturnValue;

     conn.Open();
     SqlDataReader reader = cmd.ExecuteReader();

     //如果你想select sp相關內容請影用下面兩行
     DataTable dt1 = new DataTable();  
     dt1.Load(reader);
   }

------------------------------------------------------------------------------------------------------------
十六、在Controller中取到 客戶的IP

 string getip = string.Empty;
 try
     {
        getip = Request.UserHostAddress;
     }
 catch (Exception)
     {
     }

return getip;

-----------------------------------------------------------------------------------------------------------
十七、一個後台設定就產生前端的套件(只For個大概，可以減少很多時間)

套件：umbracocms    版本：7.14(版本一定要7的，不要8的)

實作：
	步驟1：開空專案
	步驟2：去NuGet裝上這個套件
	步驟3：接下來它會一步一步告訴你

----------------------------------------------------------------------------------------------------------
十八、在Filter中取到是否是用ajax傳過來的

filterContext 就是在 Filter 中 (不管是 Action執行前，或Action執行後 會傳入的那個參數)

filterContext.HttpContext.Request.IsAjaxRequest();